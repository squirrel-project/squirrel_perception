// ROS message includes
#include "ros/ros.h"
#include <std_msgs/Float64MultiArray.h>
#include <std_msgs/Float64MultiArray.h>
#include <std_msgs/Float64MultiArray.h>

/* protected region user include files on begin */
/* protected region user include files end */

class sensor_node_config
{
public:

	//these should all be constants (currently they are not)
	 int NUM_TAC;	//number of sensors for fingertips
	 int NUM_FING;	//3 fingers
	 int NUM_PROX;	//number of proximity sensor (1)
	 int NUM_WRIST;	//number of wrist sensors
	 float SIM_TACT_LIM;
	 float SIM_PROX_LIM;
	 float SIM_WRIST_LIM;


};

class sensor_node_data
{
// autogenerated: don't touch this class
public:
    //input data
    //output data
    std_msgs::Float64MultiArray out_get_tactile;
    bool out_get_tactile_active;
    std_msgs::Float64MultiArray out_get_proximity;
    bool out_get_proximity_active;
    std_msgs::Float64MultiArray out_get_wrist;
    bool out_get_wrist_active;
};

class sensor_node_impl
{
    /* protected region user member variables on begin */
	sensor_node_data sensor_dt;
	sensor_node_config conf;
    /* protected region user member variables end */

public:
    sensor_node_impl() 
    {
        /* protected region user constructor on begin */

    	conf.NUM_TAC=4;
    	conf.NUM_PROX=1;
    	conf.NUM_FING=3;
    	conf.NUM_WRIST=6;
    	conf.SIM_TACT_LIM=5.0;
    	conf.SIM_PROX_LIM=30.0;
    	conf.SIM_WRIST_LIM=30.0;


    	sensor_dt.out_get_tactile.layout.dim.push_back(std_msgs::MultiArrayDimension());	//any clue on how to resize to a matrix?
    	sensor_dt.out_get_proximity.layout.dim.push_back(std_msgs::MultiArrayDimension());
    	sensor_dt.out_get_wrist.layout.dim.push_back(std_msgs::MultiArrayDimension());

    	//here every msg is set to 0 or neutral values

    	for(int j=0;j<conf.NUM_FING;++j){
    		for(int i=0;i<conf.NUM_TAC;++i){

    			this->sensor_dt.out_get_proximity.data.at(j+i)=0.0;
    		}
    	}

    	for(int j=0;j<conf.NUM_FING;++j){
    		for(int i=0;i<conf.NUM_PROX;++i){

    			this->sensor_dt.out_get_proximity.data.at(j+i)=0.0;
    		}
    	}

    	for(int i=0;i<conf.NUM_WRIST;++i){
    		this->sensor_dt.out_get_wrist.data.at(i)=0.0;
    	}

        /* protected region user constructor end */
    }

    void configure(sensor_node_config config) 
    {
        /* protected region user configure on begin */
        /* protected region user configure end */
    }

    void update(sensor_node_data &data, sensor_node_config config)
    {
        /* protected region user update on begin */


    	//this should go in documentation (units)
    	float tactIncrement=0.2;	//newton
    	float proxIncrement=1;	//mm
    	float wristIncrement=0.1; //< 3 x N>, <3 x Nm>



    	//here the driver is queried if any data is there, for now we send dummy data

    	//dummy code:
    	for(int j=0;j<conf.NUM_FING;++j){
   			for(int i=0;i<conf.NUM_TAC;++i){
   				//if we reached maximum or minimum we swap sign
   				if(sensor_dt.out_get_tactile.data.at(j+i)>=conf.SIM_TACT_LIM || sensor_dt.out_get_tactile.data.at(j+i)<=0.0){
   					tactIncrement=tactIncrement*-1;
   				}
   				sensor_dt.out_get_tactile.data.at(j+i)+tactIncrement;
   			}
    	}

    	for(int j=0;j<conf.NUM_FING;++j){
    	   	for(int i=0;i<conf.NUM_TAC;++i){
    	   		//if we reached maximum or minimum we swap sign
    	   		if(sensor_dt.out_get_proximity.data.at(j+i)>=conf.SIM_PROX_LIM || sensor_dt.out_get_proximity.data.at(j+i)<=0.0){
    	   			tactIncrement=tactIncrement*-1;
    	   		}
    	   		sensor_dt.out_get_proximity.data.at(j+i)+proxIncrement;
    	   	}
    	}

    	for(int j=0;j<conf.NUM_WRIST;++j){
    	   		//if we reached maximum or minimum we swap sign
    	   		if(sensor_dt.out_get_wrist.data.at(j)>=conf.SIM_WRIST_LIM || sensor_dt.out_get_wrist.data.at(j)<=0.0){
    	   			tactIncrement=tactIncrement*-1;
    	   		}
    	   		sensor_dt.out_get_wrist.data.at(j)+wristIncrement;
    	}

    	sensor_dt.out_get_wrist.layout.dim.push_back(std_msgs::MultiArrayDimension());



        /* protected region user update end */
    }


    void callback_trigger_proximity_(const bride_tutorials::TriggerPublishGoalConstPtr &goal, actionlib::SimpleActionServer<bride_tutorials::TriggerPublishAction> *as_)
    {
        /* protected region user implementation of action callback for trigger_proximity on begin */
        /* protected region user implementation of action callback for trigger_proximity end */
    }
    /* protected region user additional functions on begin */
    /* protected region user additional functions end */
};
